<html>
<head title="castaway">
    <style>
        #canvas {
            background-image: url('thumb01.png');
        }
    </style>
</head>
<body onload="init()">
    hello world
    <br />
    <label id="lblMsg"></label>
    <br />
    <button id="stopLoop">Stop loop!</button>  <button id="restartGame">RestartGame!</button>
    <br />
    <button id="earth1">[1] Fix boat!</button>  <button id="air1">[2] Get fish!</button> <button id="fire1">[3] Hit shark</button><button id="fire2">[4] Hit shark HARDER</button>
    <div style="">
        <canvas id="canvas" width="800" height="480"
                style="margin:auto; border:1px solid black; display: block;
touch-action: none; -webkit-user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
 cursor: inherit"></canvas>
    </div>
    <br />

</body>
</html>



<script language="Javascript">

    /* ---- GLOBLAS (+) ----- */
    var startTime = new Date(Date.now());
    var xpto = -1;
    var frameCount = 0;
    var color = "#FF0000";
    //var loop = null;
    var c = document.getElementById('canvas');
    var intervals = [];

    var shapeList = [];
    var currentLevel = [];

    var hud = null;
    var magePlayer = null;

    var opacity = 0.8;
    var fishToEat = 0;


    /* ---- GLOBALS (-) ----- */

    /*
    if (typeof String.prototype.startsWith != 'function') {
        // see below for better implementation!
        String.prototype.startsWith = function (str) {
            return this.indexOf(str) == 0;
        };
    }
    */

    c.onclick = function (e) {

        rect = c.getBoundingClientRect();
        mouseX = event.clientX /*+ document.body.scrollLeft */ - rect.left;
        mouseY = event.clientY /*+ document.body.scrollTop */ - rect.top;
        //mouseX = e.layerX;
        //mouseY = e.layerY;
        console.log("x: " + mouseX + "; y: " + mouseY);

        var x = Math.floor(Math.random() * 10 + 1);
        //console.log("rdm:" + x);

        var ctx = c.getContext("2d");
        ctx.fillStyle = "Red";
        ctx.fillText("|", x * 80, 300);

    }

    function clearExtraIntervals(intervalsArray) {

        for (var i = 0; i < intervalsArray.length; i++) {
            //if (i != 0) {
            clearIntervalGbl(intervalsArray[i]);
            //}
        }

        //var mLoop = intervals[0];
        //intervals = [];
        //intervals.push(mLoop);
    }

    function gameInit() {

        killAllShapes(shapeList);
        clearExtraIntervals(intervals);
        shapeList = [];
        currentLevel = [];

        startMainLoop();
        startTime = new Date(Date.now());
        xpto = -1;
        frameCount = 0;
        color = "#FF0000";
        //loop = null;
        c = document.getElementById('canvas');
        hud = null;
        fishToEat = 0;
        InitShapes();
    }

    function killAllShapes(list) {
        if (list != undefined && list != null) {
            for (var i = 0; i < list.length; i++) {
                if (list[i].kill) {
                    list[i].kill();
                    //console.log("killing " + list[i].shape.name);
                }
            }
        }
    }

    function init() {
        alert('Mr Elementualle has been in a deserter island for a couple of years, \nunexpectedly he ran into a magic coconut which gave him magical powers that will help him escape from the island. \nPress:'
+ '\n    "1"  - to fix the raft, with your earth power, and gain some health;'
+ '\n    "2"  - to catch a fish, with your air power, and gain some health;'
+ '\n    "3"  - to attack the sharks, with your fire power;'
+ '\n    <=-  - to move left;'
+ '\n    -=>  - to move right.');

        //Set up key listener
        function onkey(d, e) {
            if (!e) e = window.e;
            var c = e.keyCode;
            if (e.charCode && c == 0)
                c = e.charCode;

            //left
            if (c == 37) {
                if (this.magePlayer.direction != "L")
                    this.magePlayer.direction = "L";
                else
                    this.magePlayer.shape.vx = -d * 2;
            }

            //right
            if (c == 39) {
                if (this.magePlayer.direction != "R")
                    this.magePlayer.direction = "R";
                else
                    this.magePlayer.shape.vx = d * 2;
            }

            //key 1
            if (c == 49) {
                earthSpellLogic();
            }

            //key 2
            if (c == 50) {
                airSpellLogic();
            }

            //key 3
            if (c == 51) {
                fireSpellLogic();
            }

            //if (c == 38) keys.u1 = d; //up

            //if (c == 40) keys.d1 = d; //down

            //if (c == 65 || c == 81) keys.l2 = d; //a/q
            //if (c == 90 || c == 87) keys.u2 = d; //z/w
            //if (c == 83) keys.d2 = d; //s
            //if (c == 68) keys.r2 = d; //d

            //if (!d) {
            //    if (c == 27) { //Escape
            //        setState(INTRO);
            //    }
            //    if (c == 32) { //Scape
            //        if (state == INTRO) {
            //            introNext();
            //        }
            //    }

            //    if (c == 82) { //R
            //        if (state == INTRO || state == GAMEOVER) {
            //            setState(GAME);
            //        }
            //    }
            //}
        };
        document.onkeyup = function (e) {
            onkey(0, e);
        };
        document.onkeydown = function (e) {
            onkey(1, e);
        };


        document.getElementById("stopLoop").addEventListener('click', function () {
            funcStopLoop(intervals[0]);
            //alert("clear:" + intervals[0]);

        }, false);

        document.getElementById("restartGame").addEventListener('click', function () {
            alert("Game Restart!");
            gameInit();
        }, false);

        document.getElementById("fire1").addEventListener('click', function () {
            fireSpellLogic();
        }, false);

        document.getElementById("air1").addEventListener('click', function () {
            airSpellLogic();
        }, false);

        document.getElementById("earth1").addEventListener('click', function () {
            earthSpellLogic();
        }, false);

        function fireSpellLogic() {
            if (magePlayer != null && magePlayer != undefined) {
                var btn = document.getElementById("fire1");
                if (!btn.disabled) {
                    magePlayer.castSpell(3);
                    lockoutSubmit(btn, 1000);
                }
            }
        }

        function airSpellLogic() {
            if (magePlayer != null && magePlayer != undefined) {
                var btn = document.getElementById("air1");
                if (!btn.disabled) {
                    magePlayer.castSpell(2);
                    lockoutSubmit(btn, 1000);
                }

            }
        }

        function earthSpellLogic() {
            if (magePlayer != null && magePlayer != undefined) {
                var btn = document.getElementById("earth1");
                if (!btn.disabled) {
                    magePlayer.castSpell(1);
                    lockoutSubmit(btn, 5000);
                }
            }
        }

        gameInit();


    }


    function startMainLoop() {
        animFrame = null; // TODO: improve this for other browsers
        var intervalId = null;

        if (animFrame !== null) {
            var canvas = document.getElementById('canvas');//.get(0);

            var isMozilla = false; //$.browser.mozilla
            if (isMozilla) {
                var recursiveAnim = function () {
                    mainloop();
                    animFrame();
                };

                // setup for multiple calls
                window.addEventListener("MozBeforePaint", recursiveAnim, false);

                // start the mainloop
                animFrame();
            } else {
                var recursiveAnim = function () {
                    mainloop();
                    animFrame(recursiveAnim, canvas);
                };

                // start the mainloop
                intervalId = animFrame(recursiveAnim, canvas);
            }
        } else {
            var ONE_FRAME_TIME = 1000.0 / 60.0;
            setIntervalGbl(mainloop, ONE_FRAME_TIME);

        }
    }
    function lockoutSubmit(button, cdValue) {
        //var oldValue = button.value;
        var oldText = button.innerText;

        button.setAttribute('disabled', true);
        button.value = '...processing...';

        setTimeout(function () {
            button.innerText = oldText;
            button.removeAttribute('disabled');
        }, cdValue);

        var started = new Date(Date.now());
        var intervalMethod = function () {
            showCooldown(button, started, cdValue / 1000, oldText);
        };

        var interval = setIntervalGbl(intervalMethod, 1000); //update cooldown every sec

        setTimeout(function () {
            clearIntervalGbl(interval);
            button.value = oldText;
        }, cdValue - 1);

    }

    function showCooldown(obj, startTime, totalSeconds, oldText) {
        var now = new Date(Date.now());
        var secondsPast = new Date((now - startTime)).getSeconds();
        var totalLeft = totalSeconds - secondsPast;
        obj.innerText = oldText + " (" + totalLeft + ")";
    }

    /* ---- NAMESPACES (+) ---- */
    var lvl = {
        init: function () {
            //setInterval(function () { console.log("timerAvr: " + frameCount + " OR " + currentSeconds() + " seconds!" + new Date(Date.now()).getSeconds())}, 10*1000);
            hud = new Hud();
            //hud.init();
        },

        lvl01: function () {

            var lessThan = Math.random() < .5;

            var side1 = lessThan ? "R" : "L";
            var side2 = side1 == "R" ? "L" : "R";


            currentLevel.push(new lvlEvent(0, new Raft()));

            /*
            currentLevel.push(new lvlEvent(3, new Fish()));
            currentLevel.push(new lvlEvent(6, new Fish()));
            currentLevel.push(new lvlEvent(9, new Fish()));
            currentLevel.push(new lvlEvent(12, new Fish()));
            currentLevel.push(new lvlEvent(15, new Fish()));
            currentLevel.push(new lvlEvent(18, new Fish()));
            currentLevel.push(new lvlEvent(21, new Fish()));

            return;*/
            currentLevel.push(new lvlEvent(3, new Shark(null, side1)));
            currentLevel.push(new lvlEvent(6, new Shark(null, side1)));

            currentLevel.push(new lvlEvent(10, new Fish()));
            currentLevel.push(new lvlEvent(13, new Shark(null, null, true)));
            currentLevel.push(new lvlEvent(16, new Shark(null, side2)));
            currentLevel.push(new lvlEvent(16, new Fish()));
            currentLevel.push(new lvlEvent(18, new Shark(null, side2)));

            currentLevel.push(new lvlEvent(20, new Shark(null, side1, true))); //9
            currentLevel.push(new lvlEvent(22, new Shark(null, side1, true)));
            currentLevel.push(new lvlEvent(23, new Fish()));

            lessThan = Math.random() < .5; side1 = lessThan ? "R" : "L"; side2 = side1 == "R" ? "L" : "R";

            currentLevel.push(new lvlEvent(27, new Shark(null, side1, true)));
            currentLevel.push(new lvlEvent(29, new Shark(null, side1)));
            currentLevel.push(new lvlEvent(30, new Fish()));
            currentLevel.push(new lvlEvent(30, new Shark(null, side1, true)));
            currentLevel.push(new lvlEvent(32, new Fish()));

            currentLevel.push(new lvlEvent(33, new Shark(null, side2)));
            currentLevel.push(new lvlEvent(34, new Fish()));

            //currentLevel.push(new lvlEvent(16, new Fish()));


            //currentLevel.push(new lvlEvent(17, new Shark()));
            //currentLevel.push(new lvlEvent(18, new Shark()));
        }
    }


    var Constants = {
        PLAYER_MAX_HP: 6,
        SHARK_MAX_HP: 3,
        SPEED_NORMAL: 1,
        SPEED_ENRAGED: 2

    }

    //var NPC = {
    //    spawn: function (timer) {
    //        console.log("spawn from NPC");
    //    },

    //    kill: function () {
    //        console.log('need to implement this method on child!');
    //    },

    //    action: function () {
    //        console.log('need to implement this method on child!');
    //    }
    //}

    var Mage = function (parent) {
        this.shape = gen(parent);
        this.direction = "R";
        var that = this;
        this.spawn = function () {
            shapeList.push(that);
        }

        this.gotHit = function (hitFrom) {
            //console.log('I("' + this.shape.name + '") was hit by "' + hitFrom.shape.name + '"');
        };

        this.hitWith = function (target) {
            //console.log('I("' + this.name + '") just hit "' + target.name + '"');
            target.gotHit(this);
        }

        //this.takeDps = function (dps) {
        //    hud.health -= dps;
        //}

        this.healDps = function (dps) {
            var newHp = hud.health + dps;
            if (newHp > Constants.PLAYER_MAX_HP)
                newHp = Constants.PLAYER_MAX_HP;

            hud.health = newHp;
        }

        this.isSameDirection = function (otherShape) {
            var isRaft = that.shape.name;
            //var triz = this.shape.w /2;
            var res = otherShape.x >= this.shape.x && this.direction == "R"
                    || otherShape.x <= this.shape.x && this.direction == "L"
                    || (isRaft && (otherShape.x + otherShape.w) >= this.shape.x && otherShape.x <= (this.shape.x + this.shape.w) )

            console.log("res: " + res);
            //console.log("this.x - otherShape.x: " + (this.shape.x - otherShape.x) + " <= " + triz + "?");
            return res;
        }

        this.castSpell = function (attackId) {
            //alert(attackId);
            switch (attackId) {
                case 1: //earth, fix boat
                    var dps = 1;
                    cast(function () {
                        that.healDps(dps);
                    }, 0, null, null);
                    break;
                case 2: //air, get fish
                    castGetFish();
                    ;
                    break;
                case 3: //fire, attack shark
                    //attackShark
                    var dps = 1;
                    cast(function () { attackShark(dps); })
                    ;
                    break;
                default:
                    ;
            }
        }

        function gen(parentShape) {
            //ctx.fillRect(166, 240, 85, 130);
            var mageW = 85;
            var mageH = 130;
            var parentCenter = Math.floor(parentShape.w / 2);
            var mageCenter = Math.floor(mageW / 2);
            var mageX = parentShape.x + parentCenter - mageCenter;

            return new Shape(mageX, parentShape.y - mageH, mageW, mageH, "#038EEF", parentShape.vx, parentShape.vy, "mage")
        }


        function castGetFish() {
            setTimeout(function () { getFish(); }, 0.5 * 1000);
        }

        function getFish() {
            for (var i = 0; i < shapeList.length; i++) {
                var item = shapeList[i];

                if (item.shape.name.lastIndexOf("fish", 0) === 0) {
                    if (magePlayer.isSameDirection(item.shape)) {
                        item.catch();
                        break;
                    }
                }

            }
        }

        function attackShark(dps) {
            //get shark to attack
            for (var i = 0; i < shapeList.length; i++) {
                var item = shapeList[i];

                if (item.shape.name.lastIndexOf("shark", 0) === 0) {
                    if (magePlayer.isSameDirection(item.shape)) {
                        var newHp = item.takeDps(dps);
                        if (newHp == 0) {
                            item.kill();
                        }

                    }
                    break;
                }
            }
        }


    }

    var Raft = function () {
        this.shape = new Shape(100, 370, 184, 18, "#0000FF", 0, 0, "raft");
        var that = this;
        this.mage = new Mage(this.shape);
        this.spawn = function () {
            shapeList.push(that);
            shapeList.push(that.mage);
            magePlayer = that.mage;
        }

        this.gotHit = function (hitFrom) {
            //console.log('I("' + this.shape.name + '") was hit by "' + hitFrom.shape.name + '"');
        };

        this.hitWith = function (target) {
            //console.log('I("' + this.name + '") just hit "' + target.name + '"');
            target.gotHit(this);
        }

        this.takeDps = function (dps) {
            hud.health -= dps;
            return hud.health;
        }
    }

    var Shark = function (hp, spawnSide, goesEnrage) {
        if (goesEnrage == undefined || goesEnrage == null) goesEnrage = false;
        if (hp == undefined || hp == null) hp = 3;
        this.health = hp;

        this.attackIntervals = [];
        this.drawBlast = false;
        this.spawnSide = spawnSide;
        this.goesEnrage = goesEnrage;
        var that = this;
        this.shape = gen();

        var attack1Dps = 1;
        var _enemy = null;

        //OVERRIDE
        this.spawn = function () {
            shapeList.push(that);
            //logEveryFrameX("I just spawned " + shapeList);
        }

        this.gotHit = function (hitFrom) {
            //console.log('I("' + this.shape.name + '") was hit by "' + hitFrom.shape.name + '"');
        };

        this.hitWith = function (target) {
            //console.log('I("' + this.name + '") just hit "' + target.name + '"');
            target.gotHit(this);
            if (target.shape.name == "raft") {
                attack(target, attack1Dps);
            }
        }

        this.takeDps = function (dps) {
            this.drawBlast = true;

            setTimeout(function () {
                that.drawBlast = false;
            }, .5 * 1000);

            //console.log("this.health: " + this.health + "; this.shape.vx: " + this.shape.vx);
            if (this.health == Constants.SHARK_MAX_HP && Math.abs(this.shape.vx) == Constants.SPEED_NORMAL) {
                var signal = 1;
                if (magePlayer.shape.x < that.shape.x)
                    signal = -1;

                if (that.goesEnrage)
                    this.shape.vx = signal * Constants.SPEED_ENRAGED;
            }

            var newHp = this.health - dps;
            this.health = newHp > 0 ? newHp : 0;
            return this.health;
        }

        this.kill = function () {
            that.shape.vx = 0;
            killListIntervals(that.attackIntervals);

            setTimeout(function () {
                var pos = shapeList.indexOf(that);
                if (pos > 1)
                    shapeList.splice(pos, 1);
            }, 1 * 1000);

        }

        function gen() {
            var spawnX, spawnVx, spawnY = null;
            var spanInLeftSide = Math.random() < .5;
            //logEveryFrameX("spanInLeftSide: " + spanInLeftSide);

            if (that != undefined) {
                if (that.spawnSide != undefined && that.spawnSide != null) {
                    spanInLeftSide = (spawnSide == "L");
                    //console.log("override spawn with spawnInLeft: " + spanInLeftSide);
                }
            }

            if (spanInLeftSide) {
                spawnX = -65;
                spawnVx = Constants.SPEED_NORMAL;
            }
            else {
                spawnX = 700;
                spawnVx = -Constants.SPEED_NORMAL;
            }

            spawnY = 340 + (Math.random() * 5) * 5;

            //bool spanInLeftSide;
            //int delay
            return new Shape(spawnX, spawnY, 150, 65, "#0000FF", spawnVx, 0, "shark" + currentLevel.length);
        }



        function attack(enemy, dps) {
            if (_enemy == null) {
                _enemy = enemy;
                that.shape.vx = 0;

                var attackCastTime = 2 * 1000; //2secs
                var castMethod = function () {
                    if (that.health <= 0) {
                        that.kill(); return false;
                    }

                    console.log(that.shape.name + " is attaking " + enemy.shape.name);
                    var isStillCollided = doCollide(that.shape, enemy.shape);
                    if (isStillCollided) {
                        enemy.takeDps(dps);
                    }
                    else {
                        killListIntervals(that.attackIntervals);
                        that.shape.isCollision = false;
                        var signal = 1;
                        if (enemy.shape.x < that.shape.x)
                            signal = -1;

                        that.shape.vx = signal * Constants.SPEED_ENRAGED;
                        _enemy = null;
                        return false;
                    }
                };
                //castMethod();

                if (that.health > 0)
                    enemy.takeDps(dps); //call first time

                cast(castMethod, 1000, attackCastTime, that); //call in loop from second time forward
            }
        }

        //function cast(method, attackCastTime) {
        //    var castDelay = 1000; //1sec

        //    var timeoutMethod = function () {
        //        var intervalId = window.setInterval(method, attackCastTime);
        //        intervals.push(intervalId);
        //    };
        //    setTimeout(timeoutMethod, castDelay);
        //}


    }
    var Fish = function () {
        this.shape = gen();
        this.isCaught = false;
        var that = this;

        var attack1Dps = 1;
        var _enemy = null;

        //OVERRIDE
        this.spawn = function () {
            shapeList.push(that);

            //logEveryFrameX("I just spawned " + shapeList);
        }

        this.gotHit = function (hitFrom) {
            //console.log('I("' + this.shape.name + '") was hit by "' + hitFrom.shape.name + '"');
        };

        this.hitWith = function (target) {
            //console.log('I("' + this.name + '") just hit "' + target.name + '"');
            target.gotHit(that);
            if (target.shape.name == "raft") {
                //attack(target, attack1Dps);
            } else if (target.shape.name == "mage") {
                if (that.isCaught)
                    that.kill();
            }
        }

        this.kill = function () {
            if (this.isCaught){
                magePlayer.healDps(2);
                fishToEat++;
            }

            var pos = shapeList.indexOf(that);
            if (pos > 1)
                shapeList.splice(pos, 1);


            //console.log("fish killed! isCaught:" + this.isCaught);
        }

        this.catch = function () {
            this.isCaught = true;
        }

        function gen() {
            var spawnX, spawnVy = null;
            var spawnDistance = 10; //distance in px between fish spawns
            spawnVy = -2;
            var spanInLeftSide = Math.random() < .5;

            var randomX = Math.floor(Math.random() * spawnDistance);
            var spawnX = Math.floor(c.width / spawnDistance) * randomX;
            //var spawnX = 20;

            return new Shape(spawnX, 305, 50, 65, "#FFFF00", 0, spawnVy, "fish" + currentLevel.length);
        }

        //function attack(enemy, dps) {
        //    if (_enemy == null) {
        //        _enemy = enemy;
        //        that.shape.vx = 0;

        //        var attackCastTime = 2 * 1000; //2secs
        //        var castMethod = function () {
        //            enemy.takeDps(dps);
        //        };
        //        //castMethod();
        //        cast(castMethod, attackCastTime);
        //    }
        //}
    }

    function cast(method, castDelay, attackCastTime, iShape) {
        if (castDelay == undefined || castDelay == null)
            castDelay = 0.5 * 1000; //0.5sec



        var timeoutMethod = function () {
            if (attackCastTime == undefined || attackCastTime == null) {
                method(); //call method
            } else {
                var intervalId = setIntervalGbl(method, attackCastTime);
                if (iShape != undefined && iShape != null) {
                    iShape.attackIntervals.push(intervalId);
                }
            }
        };

        console.log("timeoutMethod:" + timeoutMethod);
        setTimeout(timeoutMethod, castDelay);
    }

    /* ---- NAMESPACES (-) ---- */

    function ChangeColor(val) {
        if (color == "#FF0000") {
            return "#00FF00";
        } else {
            return "#FF0000";
        }
    }

    function killListIntervals(list) {
        if (list != null && list != undefined) {
            for (var i = 0; i < list.length; i++) {
                clearIntervalGbl(list[i]);
            }
        }
    }

    function setIntervalGbl(handler, timeout) {
        var intervalId = window.setInterval(handler, timeout);
        intervals.push(intervalId);
        return intervalId;
    }

    function clearIntervalGbl(id) {
        if (intervals != undefined && intervals != null) { }
        var pos = intervals.indexOf(id);
        if (pos > 0) {
            intervals.splice(pos, 1);
        }
        window.clearInterval(id);
    }


    function InitShapes() {

        /*
        var arr = [];
        arr.push(1);
        arr.push(2);
        arr.push(3);
        arr.push(4);
        console.log("arr:" + arr);
        arr.shift();
        console.log("arr.poped; arr: " + arr);
        */

        lvl.init();
        lvl.lvl01(); //INIT level 01;
        //shapeList.push(new Shape(10, 0, 25, 25, "#00FFFF", 1, 1, "sUm"));
        //shapeList.push(new Shape(0, 40, 39, 25, "#00FF00", -1, -1, "sDois"));
        //shapeList.push(new Shape(0, 80, 100, 25, "#0000FF", -1, 1, "sTres"));



        //shapeList.push(new Shape(600, 350, 150, 65, "#0000FF", 1, 0, "shark"));
        //shapeList.push(new Shape(565, 200, 50, 65, "#0000FF", 0, 1, "fish"));

        /*
        var xpto = new Shark();
        xpto.NPC.spawn(null);
        */
    }

    function updateGame() {
        //logEveryFrameX(Math.random()<.5, 100);
        frameCount++;
        document.getElementById("lblMsg").innerText = xpto;
        var ctx = c.getContext("2d");
        ctx.globalAlpha = opacity;
        ctx.clearRect(0, 0, c.width, c.height);

        if (hud.health <= 0) {
            funcStopLoop(intervals[0]);
            clearExtraIntervals(intervals);
            currentLevel = null;
            var playAgain = confirm("Game Over! You survived " + currentSeconds() + " seconds!")
            if (playAgain)
                gameInit();
            else {
                clearExtraIntervals(intervals);
                funcStopLoop(intervals[0]);
            }
            //console.log("Game Over!");
        }

        //START LOGIC:
        if (currentLevel != null) {
            while (currentLevel.length > 0
                    && currentLevel[0].spawnTime <= currentSeconds()) {
                var event = currentLevel.shift().event;
                event.spawn(null);
            }
        }

        /*
        var imgBg = new Image();
        imgBg.src = "thumb01.png";
        imgBg.onload = function () {
            ctx.drawImage(imgBg, 0, 0);
        }
        */

        for (var i in shapeList) {
            shapeList[i].shape.isCollision = false; //reset collision;
            var iShape = moveShape(shapeList[i], c);
            if (iShape != null) {
                currShape = iShape.shape;

                ctx.fillStyle = getFill(currShape);
                ctx.fillRect(currShape.x, currShape.y, currShape.w, currShape.h);
                write(iShape);

                //if (iShape.shape.name == "mage") {

                //}
            }
        }


        /*
        var newXpto = xpto++;
        ctx.fillStyle = color;
        if (xpto > 480)
        {
            color = ChangeColor(xpto);
            xpto = -1;
        }
        ctx.fillRect(0, 0, xpto++, 75);
        */

        debug()

    }

    function debug() {
        //var ctx = c.getContext("2d");
        //ctx.globalAlpha = 0.5;
        //ctx.fillStyle = "Green";
        //ctx.fillRect(0, 220, c.width, 60);

        //mage
        //ctx.fillRect(166, 240, 85, 130);

        //ctx.globalAlpha = 1;
    }

    function drawBlast(x, y) {
        //var ctx = c.getContext("2d");
        //ctx.fillStyle = "White";
        //ctx.fillText("BLAST!!!", x + 40, y + 20);

        //return;
        var radius = 80;
        var context = c.getContext("2d");
        context.beginPath();
        context.arc(x, y, radius, Math.PI, 2 * Math.PI, false);
        context.fillStyle = '#FFA500';
        context.fill();
        context.lineWidth = 5;
        context.strokeStyle = '#FF8C00';
        context.stroke();
    }

    function moveShape(iShape, canvas) {
        var speed = 1; //Math.random() * 2;
        var shape = iShape.shape;
        var isRaft = (shape.name == "raft");

        if (shape.name.lastIndexOf("fish", 0) === 0) {
            var playerMiddleX = this.magePlayer.shape.x + (this.magePlayer.shape.w / 2);
            var playerMiddleY = this.magePlayer.shape.y + (this.magePlayer.shape.h / 2);

            var diff = shape.x - playerMiddleX;
            //console.log("shape.y " + shape.y + "; playerMiddleY: " + playerMiddleY);
            if (iShape.isCaught) {
                var speedCaught = 14;
                if (Math.abs(shape.x - playerMiddleX) <= speedCaught + 5 && shape.y <= playerMiddleY) {
                    //iShape.kill();
                }
                else {

                    var signalY = this.magePlayer.shape.y < shape.y ? -1 : 1;
                    shape.vy = signalY * speedCaught;

                    var signalX = playerMiddleX < shape.x ? -1 : 1;
                    shape.vx = signalX * speedCaught;
                }
            } else if ((shape.y) <= 220)
                shape.vy *= -1;
            else if ((shape.y) >= 320 && shape.vy > 0) {
                iShape.kill();
                return null;
            }
        } else if (isRaft) {
            shape.vx = this.magePlayer.shape.vx;
        }

        var isRaftOrMage = isRaft || shape.name == "mage";
        var movedShape = clippedMoveTo(iShape, isRaftOrMage);

        //check X boundaries
        //if (!isWithinXCanvas(movedShape, canvas)) {
        //    shape.vx = 0;
        //    movedShape.x = shape.x + speed * (shape.vx);
        //}

        ////check Y boundaries
        //if (!isWithinYCanvas(movedShape, canvas)) {
        //    shape.vy = 0;
        //    movedShape.y = shape.y + speed * (shape.vy);
        //}

        shape.x = movedShape.x;
        shape.y = movedShape.y;


        var currShapeIndex = shapeList.indexOf(iShape);
        //for each shape that has already been moved (before currIndex), check if this move colides!
        for (var i = 0; i < currShapeIndex; i++) {
            var colided = doCollide(shape, shapeList[i].shape);
            shape.isCollision |= colided;

            if (colided) {
                iShape.hitWith(shapeList[i]);
                //console.log("'" + shape.name + "' colidede with '" + shapeList[i].shape.name+ "'");
            }

            //if (flag)
            //    logEveryFrameX("checking coll between '"+shape.name+"' and '"+shapeList[i].name+"'");

            //if (shape.isCollision)
            //  logEveryFrameX("'" + shape.name + "' colided with '" + shapeList[i].name + "'");
        }

        //logEveryFrameX("name: " + shape.name + "; x:" + shape.x + "; y:" + shape.y, 100);
        iShape.shape = shape;
        return iShape;
    }

    function clippedMoveTo(iShape, forceClipping) {
        var speed = 1;
        var calculateNextPos = function (s) {
            return new Shape(s.x + speed * (s.vx),
                s.y + speed * (s.vy),
                s.w, s.h, s.fill, s.vx, s.vy, s.name);
        };

        if (forceClipping) {
            var clipShape = function (notClipped, toClip) {
                if (toClip == undefined)
                    toClip = notClipped;

                var xDiff = 0;
                if (notClipped.x < 0) {
                    xDiff = notClipped.x - 0;
                    var newX = toClip.x + xDiff;
                    var raftMin = -(notClipped.x - toClip.x);
                    if (newX < raftMin && toClip.name == "raft") {
                        newX = raftMin;
                    } else if (newX < 0 && toClip.name == "mage") {
                        newX = 0;
                    }

                    toClip.x = newX;
                } else if (notClipped.x + notClipped.w > canvas.width) {
                    xDiff = canvas.width - (notClipped.w + notClipped.x);
                    toClip.x = toClip.x + xDiff;
                }
                return toClip;
            };

            var clipped = null;
            if (iShape.shape.name == "raft") {
                var playerNextPos = calculateNextPos(this.magePlayer.shape);
                var raftNextPos = calculateNextPos(iShape.shape);
                clipped = clipShape(playerNextPos, raftNextPos);
            } else {
                var shapeNextPos = calculateNextPos(iShape.shape);
                clipped = clipShape(shapeNextPos);
            }
            return clipped;
        } else {
            return calculateNextPos(iShape.shape);
        }
    }

    function doCollide(s1, s2) {

        if (s1.x < s2.x + s2.w &&
            s1.x + s1.w > s2.x &&
            s1.y < s2.y + s2.h &&
            s1.h + s1.y > s2.y) {
            return true;
        }
        return false;


        var xd = s1.x - s2.x;
        var yd = s1.y - s2.y;
        var wt = s2.w + s1.w;

        var c = document.getElementById('canvas');
        var context = c.getContext("2d");
        context.beginPath();
        context.moveTo(xd, yd);
        context.lineTo(yd, wt);
        context.lineTo(wt, xd);
        context.stroke();

        //context.fillStyle = "#B97A57";
        //context.fillRect(xd, yd, wt, s1.h + s2.h);


        return (xd * xd + yd * yd <= wt * wt);
    }

    function drawGame() {
        hud.draw();
    }


    function getFill(shape) {
        if (shape.isCollision && false) {
            return "#FF0000";
        }
        else {
            return shape.fill;
        }
    }

    function lvlEvent(spawnTime, event) {
        this.spawnTime = spawnTime;
        this.event = event;
    }

    function Shape(x, y, w, h, fill, vx, vy, name) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.fill = fill;
        this.vx = vx;
        this.vy = vy;
        this.name = name;
        this.isCollision = false;
        this.ignoreRightBottomCanvas = true;
    }

    function write(iShape) {
        var shape = iShape.shape;
        var ctx = c.getContext("2d");
        ctx.fillStyle = "Red";
        ctx.fillText(shape.name, shape.x, shape.y);

        if (shape.name.lastIndexOf("shark", 0) === 0) {
            ctx.fillStyle = "White";
            ctx.fillText(iShape.health, shape.x + 40, shape.y + 20);

            //console.log(iShape.drawBlast);
            if (iShape.drawBlast) {
                drawBlast(shape.x + shape.w / 2, shape.y + 20);
            }
        } else if (iShape.shape.name == "mage") {
            if (this.magePlayer.direction == "R") {
                ctx.fillText("=>", shape.x + (shape.w / 2) - 15, shape.y + 30)
            } else {
                ctx.fillText("<=", shape.x + (shape.w / 2) - 15, shape.y + 30)
            }
        }
    }

    function logPos(shape, logIt) {
        var msg = "name:" + shape.name + " x: " + shape.x + "; y: " + shape.y;
        if (logIt)
            console.log(msg);
        return msg;
    }

    function Hud(hp, str) {
        if (hp == undefined) {
            hp = Constants.PLAYER_MAX_HP;
        }
        if (str == undefined)
            str = 10;

        //this.init = function () {
        //        strength = 10;
        //        draftHealth = 6;
        //}
        this.strength = str;
        this.health = hp;
        this.draw = function () {
            var ctx = c.getContext("2d");
            ctx.font = '15pt Verdana';
            ctx.fillStyle = "Black";
            var hpTxt = "Health:     " + this.health;
            var strengthTxt = "Strength: " + this.strength;

            var y = 30;
            ctx.fillText(hpTxt, 10, y);
            //ctx.fillText(strengthTxt, 10, y + 25);

            ctx.fillText("FishToEat: " + fishToEat, 10, y + 2 * 25);

            ctx.fillText("Time: " + currentSeconds(), c.width - 130, y);

            if (magePlayer != null && magePlayer != undefined) {
                var direction = "->";
                if (magePlayer.direction == "L")
                    direction = "<-";

                //ctx.fillText("SIDE: " + direction, 10, y + 3 * 25);
            }
            //debugHud(this);

        }

        function debugHud(obj) {
            var ctx = c.getContext("2d");
            ctx.fillText("FishToEat: " + fishToEat, 10, obj.y + 2 * 25);

            if (magePlayer != null && magePlayer != undefined) {
                var direction = "->";
                if (magePlayer.direction == "L")
                    direction = "<-";

                //ctx.fillText("SIDE: " + direction, 10, obj.y + 3 * 25);
            }


        }

        //this.updateHud = function(hp, str) {
        //    if(hp != undefined && hp != null){
        //        this.drafthealth = hp;
        //    }
        //    if(str != undefined && str != null)
        //        strength = str;
        //};

        //function updateHud(hp, str) {
        //    if (hp != undefined && hp != null)
        //        draftHealth = hp;
        //    if (str != undefined && str != null)
        //        strength = str;
        //}
    }

    function isWithinXCanvas(shape, canvas) {
        //logEveryFrameX("X:{0}; x >= 0?: {1}; x <= canvas.width({2}): {3}".format(shape.x, thi, shape.y, canvas.height));
        return shape.ignoreRightBottomCanvas || (shape.x >= 0 && shape.x + shape.w <= canvas.width);
    }

    function isWithinYCanvas(shape, canvas) {
        return shape.ignoreRightBottomCanvas || (shape.y >= 0 && shape.y + shape.h <= canvas.height);
    }

    function isWithinCanvas(shape, canvas) {
        return isWithinXCanvas(shape, canvas) && isWithinYCanvas(shape, canvas);
    }



    var mainloop = function () {
        updateGame();
        drawGame();

        //if (this.magePlayer != undefined) {
        //    var msg = logPos(shapeList.length, false);
        //    logEveryFrameX(msg, 100);
        //}
    };

    var animFrame = window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            null;



    function funcStopLoop(loop2) {
        if (animFrame !== null) {
            console.log('TODO');
        } else {
            clearIntervalGbl(loop2);
            //console.log(loop2);
        }
    }

    function logEveryFrameX(val, frameX) {
        if (frameCount % frameX == 0 || frameCount == 1 || frameX == undefined) {
            console.log(val);
        }
    }

    function currentSeconds(now) {
        if (now == undefined)
            now = new Date(Date.now());

        return new Date((now - startTime)).getSeconds();
    }
</script>