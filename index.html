<html>
<head title="castaway">
    <style>
        #canvas {
            background-image: url('thumb01.png');
        }
    </style>
</head>
<body onload="init()">
    hello world
    <br />
    <label id="lblMsg"></label>
    <br />
    <button id="restartGame">RestartGame!</button>
    <div style="">
        <canvas id="canvas" width="800" height="480"
                style="margin:auto; border:1px solid black; display: block;
touch-action: none; -webkit-user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
 cursor: inherit"></canvas>
    </div>
    <br />
    <button id="stopLoop">Stop loop!</button>
</body>
</html>



<script language="Javascript">

    /* ---- GLOBLAS (+) ----- */
    var startTime = new Date(Date.now());
    var xpto = -1;
    var frameCount = 0;
    var color = "#FF0000";
    //var loop = null;
    var c = document.getElementById('canvas');
    var intervals = [];

    var shapeList = [];
    var currentLevel = [];

    var hud = null;


    /* ---- GLOBALS (-) ----- */

    function clearExtraIntervals(intervalsArray) {
        
        for (var i = 0; i < intervalsArray.length; i++) {
            if (i != 0) {
                window.clearInterval(intervalsArray[i]);
            }
        }

        var mLoop = intervals[0];
        intervals = [];
        intervals.push(mLoop);
    }

    function gameInit() {
        clearExtraIntervals(intervals);
        startTime = new Date(Date.now());
        xpto = -1;
        frameCount = 0;
        color = "#FF0000";
        //loop = null;
        c = document.getElementById('canvas');
        shapeList = [];
        currentLevel = [];
        hud = null;
        InitShapes();
    }

    function init() {
        document.getElementById("stopLoop").addEventListener('click', function () {
            funcStopLoop(intervals[0]);
            //alert("clear:" + intervals[0]);
            
        }, false);

        document.getElementById("restartGame").addEventListener('click', function () {
            alert("Game Restart!");
            gameInit();
        }, false);

        animFrame = null; // TODO: improve this for other browsers
        var intervalId = null;

        if (animFrame !== null) {
            var canvas = document.getElementById('canvas');//.get(0);

            var isMozilla = false; //$.browser.mozilla
            if (isMozilla) {
                var recursiveAnim = function () {
                    mainloop();
                    animFrame();
                };

                // setup for multiple calls
                window.addEventListener("MozBeforePaint", recursiveAnim, false);

                // start the mainloop
                animFrame();
            } else {
                var recursiveAnim = function () {
                    mainloop();
                    animFrame(recursiveAnim, canvas);
                };

                // start the mainloop
                intervalId = animFrame(recursiveAnim, canvas);
            }
        } else {
            var ONE_FRAME_TIME = 1000.0 / 60.0;
            intervalId = window.setInterval(mainloop, ONE_FRAME_TIME);
            
        }
        intervals.push(intervalId);
        console.log("INTERVALID: " + intervalId);
        gameInit();
    }



    /* ---- NAMESPACES (+) ---- */
    var lvl = {
        init: function () {
            //setInterval(function () { console.log("timerAvr: " + frameCount + " OR " + currentSeconds() + " seconds!" + new Date(Date.now()).getSeconds())}, 10*1000);
            hud = new Hud();
            //hud.init();
        },

        lvl01: function () {
            currentLevel.push(new lvlEvent(1, new Raft()));
            currentLevel.push(new lvlEvent(2, new Shark()));
        }
    }


    var NPC = {
        spawn: function (timer) {
            console.log("spawn from NPC");
        },

        kill: function () {
            console.log('need to implement this method on child!');
        },

        action: function () {
            console.log('need to implement this method on child!');
        }
    }

    var Raft = function () {
        this.shape = new Shape(135, 370, 184, 18, "#0000FF", 0, 0, "raft");
        var that = this;
        this.spawn = function () {
            shapeList.push(that);
        }

        this.gotHit = function (hitFrom) {
            console.log('I("' + this.shape.name + '") was hit by "' + hitFrom.shape.name + '"');
        };

        this.hitWith = function (target) {
            //console.log('I("' + this.name + '") just hit "' + target.name + '"');
            target.gotHit(this);
        }

        this.takeDps = function (dps) {
            hud.health -= dps;
        }
    }

    var Shark = function () {
        this.shape = gen();
        var that = this;

        var attack1Dps = 1;
        var _enemy = null;

        //OVERRIDE
        this.spawn = function () {
            console.log(that.shape);
            shapeList.push(that);

            logEveryFrameX("I just spawned " + shapeList);
        }

        this.gotHit = function (hitFrom) {
            console.log('I("' + this.shape.name + '") was hit by "' + hitFrom.shape.name + '"');
        };

        this.hitWith = function (target) {
            //console.log('I("' + this.name + '") just hit "' + target.name + '"');
            target.gotHit(this);
            if (target.shape.name == "raft") {
                attack(target, attack1Dps);
            }
        }

        function gen() {
            var spawnX, spawnVx = null;
            var spanInLeftSide = Math.random() < .5;
            logEveryFrameX("spanInLeftSide: " + spanInLeftSide);
            if (spanInLeftSide) {
                spawnX = -65;
                spawnVx = 1;
            }
            else {
                spawnX = 700;
                spawnVx = -1;
            }

            //bool spanInLeftSide;
            //int delay
            return new Shape(spawnX, 350, 150, 65, "#0000FF", spawnVx, 0, "shark" + shapeList.length);
        }

        function attack(enemy, dps) {
            if (_enemy == null) {
                _enemy = enemy;
                that.shape.vx = 0;

                var attackCastTime = 2 * 1000; //2secs
                var castMethod = function () {
                    enemy.takeDps(dps);
                };
                //castMethod();
                cast(castMethod, attackCastTime);
            }
        }

        function cast(method, attackCastTime) {
            var castDelay = 1000; //1sec

            var timeoutMethod = function () {
                var intervalId = window.setInterval(method, attackCastTime);
                intervals.push(intervalId);
            };
            setTimeout(timeoutMethod, castDelay);
        }
    }

    /* ---- NAMESPACES (-) ---- */

    function ChangeColor(val) {
        if (color == "#FF0000") {
            return "#00FF00";
        } else {
            return "#FF0000";
        }
    }

    function InitShapes() {

        /*
        var arr = [];
        arr.push(1);
        arr.push(2);
        arr.push(3);
        arr.push(4);
        console.log("arr:" + arr);
        arr.shift();
        console.log("arr.poped; arr: " + arr);
        */

        lvl.init();
        lvl.lvl01(); //INIT level 01;
        //shapeList.push(new Shape(10, 0, 25, 25, "#00FFFF", 1, 1, "sUm"));
        //shapeList.push(new Shape(0, 40, 39, 25, "#00FF00", -1, -1, "sDois"));
        //shapeList.push(new Shape(0, 80, 100, 25, "#0000FF", -1, 1, "sTres"));



        //shapeList.push(new Shape(600, 350, 150, 65, "#0000FF", 1, 0, "shark"));
        //shapeList.push(new Shape(565, 200, 50, 65, "#0000FF", 0, 1, "fish"));

        /*
        var xpto = new Shark();
        xpto.NPC.spawn(null);
        */
    }

    function updateGame() {
        //logEveryFrameX(Math.random()<.5, 100);
        frameCount++;
        document.getElementById("lblMsg").innerText = xpto;
        var ctx = c.getContext("2d");
        ctx.clearRect(0, 0, c.width, c.height);

        if (hud.health <= 0) {
            window.clearExtraIntervals(intervals);
            //funcStopLoop(intervals[0]);
            alert("Game Over!");
            gameInit();
            //console.log("Game Over!");
        }

        //START LOGIC:
        while (currentLevel.length > 0
                && currentLevel[0].spawnTime <= currentSeconds()) {
            var event = currentLevel.shift().event;
            //console.log("currentLevel.length: " + currentLevel.length);
            console.log("Going to spanw a " + event.shape.name);
            event.spawn(null);

        }

        /*
        var imgBg = new Image();
        imgBg.src = "thumb01.png";
        imgBg.onload = function () {
            ctx.drawImage(imgBg, 0, 0);
        }
        */

        for (var i in shapeList) {
            shapeList[i].shape.isCollision = false; //reset collision;
            currShape = moveShape(shapeList[i], c).shape;
            ctx.fillStyle = getFill(currShape);
            ctx.fillRect(currShape.x, currShape.y, currShape.w, currShape.h);
            write(currShape);
        }


        /*
        var newXpto = xpto++;
        ctx.fillStyle = color;
        if (xpto > 480)
        {
            color = ChangeColor(xpto);
            xpto = -1;
        }
        ctx.fillRect(0, 0, xpto++, 75);
        */


    }

    function moveShape(iShape, canvas) {
        var speed = 1; //Math.random() * 2;

        var shape = iShape.shape;
        var movedShape = new Shape(shape.x + speed * (shape.vx),
            shape.y + speed * (shape.vy),
            shape.w, shape.h, shape.fill, null, null, null);

        //logEveryFrameX("withinX: " + isWithinXCanvas(movedShape, canvas))
        //check X boundaries
        if (!isWithinXCanvas(movedShape, canvas)) {
            shape.vx *= -1;
            movedShape.x = shape.x + speed * (shape.vx);
        }

        //check Y boundaries
        if (!isWithinYCanvas(movedShape, canvas)) {
            shape.vy *= -1;
            movedShape.y = shape.y + speed * (shape.vy);
        }

        shape.x = movedShape.x;
        shape.y = movedShape.y;


        var flag = shape.name == "sTres";
        var currShapeIndex = shapeList.indexOf(iShape);

        if (flag)
            logEveryFrameX("currShpeIndex: " + currShapeIndex, 100);

        //for each shape that has already been moved (before currIndex), check if this move colides!
        for (var i = 0; i < currShapeIndex; i++) {
            var colided = doCollide(shape, shapeList[i].shape);
            shape.isCollision |= colided;

            if (colided) {
                iShape.hitWith(shapeList[i]);
            }

            //if (flag)
            //    logEveryFrameX("checking coll between '"+shape.name+"' and '"+shapeList[i].name+"'");

            //if (shape.isCollision)
            //  logEveryFrameX("'" + shape.name + "' colided with '" + shapeList[i].name + "'");
        }

        //logEveryFrameX("name: " + shape.name + "; x:" + shape.x + "; y:" + shape.y, 100);
        iShape.shape = shape;
        return iShape;
    }

    function doCollide(s1, s2) {

        if (s1.x < s2.x + s2.w &&
            s1.x + s1.w > s2.x &&
            s1.y < s2.y + s2.h &&
            s1.h + s1.y > s2.y) {
            return true;
        }
        return false;


        var xd = s1.x - s2.x;
        var yd = s1.y - s2.y;
        var wt = s2.w + s1.w;

        var c = document.getElementById('canvas');
        var context = c.getContext("2d");
        context.beginPath();
        context.moveTo(xd, yd);
        context.lineTo(yd, wt);
        context.lineTo(wt, xd);
        context.stroke();

        //context.fillStyle = "#B97A57";
        //context.fillRect(xd, yd, wt, s1.h + s2.h);


        return (xd * xd + yd * yd <= wt * wt);
    }

    function drawGame() {
        hud.draw();
        //console.log("drawn!");
    }


    function getFill(shape) {
        if (shape.isCollision) {
            return "#FF0000";
        }
        else {
            return shape.fill;
        }
    }

    function lvlEvent(spawnTime, event) {
        this.spawnTime = spawnTime;
        this.event = event;
    }

    function Shape(x, y, w, h, fill, vx, vy, name) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.fill = fill;
        this.vx = vx;
        this.vy = vy;
        this.name = name;
        this.isCollision = false;
        this.ignoreRightBottomCanvas = true;
    }

    function write(shape) {
        var ctx = c.getContext("2d");
        ctx.fillStyle = "Red";
        ctx.fillText(shape.name, shape.x, shape.y);
    }

    function Hud(hp, str) {
        if (hp == undefined) {
            hp = 6;
        }
        if (str == undefined)
            str = 10;

        //this.init = function () {
        //        strength = 10;
        //        draftHealth = 6;
        //}

        this.strength = str;
        this.health = hp;
        this.draw = function () {
            var ctx = c.getContext("2d");
            ctx.font = '15pt Verdana';
            ctx.fillStyle = "Black";
            var hpTxt = "Health:     " + this.health;
            var strengthTxt = "Strength: " + this.strength;

            var y = 30;
            ctx.fillText(hpTxt, 10, y);
            ctx.fillText(strengthTxt, 10, y + 25);
        }

        //this.updateHud = function(hp, str) {
        //    if(hp != undefined && hp != null){
        //        this.drafthealth = hp;
        //    }
        //    if(str != undefined && str != null)
        //        strength = str;
        //};

        //function updateHud(hp, str) {
        //    if (hp != undefined && hp != null)
        //        draftHealth = hp;
        //    if (str != undefined && str != null)
        //        strength = str;
        //}
    }

    function isWithinXCanvas(shape, canvas) {
        //logEveryFrameX("X:{0}; x >= 0?: {1}; x <= canvas.width({2}): {3}".format(shape.x, thi, shape.y, canvas.height));
        return shape.ignoreRightBottomCanvas || (shape.x >= 0 && shape.x + shape.w <= canvas.width);
    }

    function isWithinYCanvas(shape, canvas) {
        return shape.ignoreRightBottomCanvas || (shape.y >= 0 && shape.y + shape.h <= canvas.height);
    }

    function isWithinCanvas(shape, canvas) {
        return isWithinXCanvas(shape, canvas) && isWithinYCanvas(shape, canvas);
    }



    var mainloop = function () {
        updateGame();
        drawGame();
    };

    var animFrame = window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            null;



    function funcStopLoop(loop2) {
        if (animFrame !== null) {
            console.log('TODO');
        } else {
            window.clearInterval(loop2);
            console.log(loop2);
        }
    }

    function logEveryFrameX(val, frameX) {
        if (frameCount % frameX == 0 || frameCount == 1 || frameX == undefined) {
            console.log(val);
        }
    }

    function currentSeconds(now) {
        if (now == undefined)
            now = new Date(Date.now());

        return new Date((now - startTime)).getSeconds();
    }
</script>